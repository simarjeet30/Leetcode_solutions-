1. Two Sum

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector <int>ans;
        for (int i =0;i<nums.size();i++)
        {
            for (int j=i+1;j<nums.size();j++)
            {
                if (nums[i]+nums[j]==target)
                {
                    ans.push_back(i);
                    ans.push_back(j);
                    
                }
            }
        }return (ans);
    }
    
};


9. Palindrome Number

class Solution {
public:
    bool isPalindrome(int x) 
    {
       long int p=x;
       long int y=0;
       while(x)
       {
           y *= 10;
           y += x % 10;
           x /= 10;
       }
       //for rejecting -121 like cases
       if (p!=y||p<0)
       {
           return false;
       }
       else{
           return true;
       }
        
    }
    
    
};


13. Roman to Integer

class Solution {
public:
    int romanToInt(string s) {
        int ans=0,k;
        for (int i=0;i<s.length();i++)
        {
            if (s[i]=='I')
            {
                if (s[i+1]=='V')
                {
                    ans=ans+4;
                    i=i+1;    
                }
                else if (s[i+1]=='X')
                {
                    ans=ans+9;
                    i=i+1;   
                }
                else
                {
                    ans=ans+1;    
                }
            }
            else if (s[i]=='X')
            {
                if (s[i+1]=='L')
                {
                    ans=ans+40;
                    i=i+1;    
                }
                else if (s[i+1]=='C')
                {
                    ans=ans+90;
                    i=i+1; 
                }
                else
                {
                    ans=ans+10;
                }
            }
            else if (s[i]=='C')
            {
                if (s[i+1]=='D')
                {
                    ans=ans+400;
                    i=i+1;
                }
                else if (s[i+1]=='M')
                {
                    ans=ans+900;
                    i=i+1;
                }
                else
                {
                    ans=ans+100;   
                }
            }
            
            else if (s[i]=='V')
            {
                ans=ans+5;    
            }
            else if (s[i]=='L')
            {
                ans=ans+50;   
            }
            else if (s[i]=='D')
            {
                ans=ans+500;    
            }
            else if (s[i]=='M')
            {
                ans=ans+1000;
            }
        
        }
      return ans;  
    }
};


14. Longest Common Prefix

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int n=strs.size();
        if (n==0)
        {
            return "";
        }
        if (n==1)
        {
            return strs[0];
        }
        sort (strs.begin(), strs.begin()+n);
        int en=min(strs[0].size(),strs[n-1].size());
        string first = strs[0], last = strs[n - 1];
        int i = 0;
        while (i < en && first[i] == last[i])
        i++;
 
        string s = first.substr(0, i);
        return s;  
    }
};

20. Valid Parentheses

class Solution {
public:
bool isValid(string s) {
        stack<char> st;
        if (s.length()%2!=0)
        return false;
        for (int i=0;i<s.length();i++)
        {
            if(s[i] == '{' or s[i] == '(' or s[i] == '[')
            {
                st.push(s[i]);
                
            }
            else if (st.empty())
            {
                return false;
            }
            else if ((s[i] == '}' and st.top() == '{') or (s[i] == ']' and st.top() == '[') or (s[i] == ')' and st.top() == '('))
            {
                st.pop();
            }
            else
            {
                return false;
            }
        }
        return (st.empty());
    }
};

21. Merge Two Sorted Lists

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
    {
        ListNode *Head;
        if (!l1)
        return l2;
        if (!l2)
        return l1;

    if (l1->val <= l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }


    }
};

28. Implement strStr()

class Solution {
public:
    int strStr(string haystack, string needle) {
        int result=0;
        for(int i=0;i<haystack.size();i++)
        {
            if (haystack[i]==needle[0])
            {
                result=i;
                int ind=i++;
                int j;
                for (j=1;j<needle.size();j++)
                {
                    if (haystack[i]!=needle[j])
                        {
                            result=0;
                            break;
                        }
                        i++;
                    
                }
                if (j==needle.size())
                    return result;
                
                else
                    i=ind;
                
            }
        
    }
    return -1;
        
    }
};

94. Binary Tree Inorder Traversal

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> v;
    vector<int> inorderTraversal(TreeNode* root) {
        
        if (root==NULL)
           return v;
        inorderTraversal(root->left);
        v.push_back(root->val);
        inorderTraversal(root->right);
        return v;
        
    }
};

100. Same Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p==NULL&&q==NULL)
        return true;
        if (p==NULL||q==NULL)
            return false;
        if (p->val!=q->val)
            return false;
        return (isSameTree(p->left,q->left)&&isSameTree(p->right,q->right));    
        
    }
};

101. Symmetric Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root==NULL)
            return true;
        else
            return sym (root->left,root->right);
    }
    bool sym(TreeNode* p,TreeNode* q)
    {
        if(p==NULL or q==NULL)
            return p==q;
        if (p->val!=q->val)
            return false;
        return (sym (p->left,q->right)&&
        sym (p->right,q->left));
        
        
    }
};

104. Maximum Depth of Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
   
    int maxDepth(TreeNode* root) {
        if (root==NULL)
            return 0;
        int a=root->left?maxDepth(root->left):0;
        int b=root->right?maxDepth(root->right):0;
        
       return max(a,b)+1; 
    }
};

108. Convert Sorted Array to Binary Search Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

TreeNode* Build_the_tree(vector<int>& arr, int l, int r)
{
    if(l>r)
    {
        return NULL;
    }
        
    int m=(l+r)/2;
    
    TreeNode* term=new TreeNode(arr[m]);
    
    term->left=Build_the_tree(arr, l, m-1);
    term->right=Build_the_tree(arr, m+1, r);
    
    return term;
}

TreeNode* sortedArrayToBST(vector<int>& nums) {
    return Build_the_tree(nums, 0, nums.size()-1);
}
};

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::I M P:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
110. Balanced Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
bool res = true;
bool isBalanced(TreeNode* root) {
if(root)traverse(root);
return res;
}

int traverse(TreeNode* root){
    //if root->left exist then traverse(root->left) else 0
    int a = root->left ? traverse(root->left) : 0;
    int b = root->right ? traverse(root->right) : 0;
    if((a-b) > 1 || (a-b) < -1) res = false;
    //ading 1 as initial root node is aldo to be added for depth
    return max(a, b) + 1;
}
    
};






