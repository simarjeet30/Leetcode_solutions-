1. Two Sum

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector <int>ans;
        for (int i =0;i<nums.size();i++)
        {
            for (int j=i+1;j<nums.size();j++)
            {
                if (nums[i]+nums[j]==target)
                {
                    ans.push_back(i);
                    ans.push_back(j);
                    
                }
            }
        }return (ans);
    }
    
};


9. Palindrome Number

class Solution {
public:
    bool isPalindrome(int x) 
    {
       long int p=x;
       long int y=0;
       while(x)
       {
           y *= 10;
           y += x % 10;
           x /= 10;
       }
       //for rejecting -121 like cases
       if (p!=y||p<0)
       {
           return false;
       }
       else{
           return true;
       }
        
    }
    
    
};


13. Roman to Integer

class Solution {
public:
    int romanToInt(string s) {
        int ans=0,k;
        for (int i=0;i<s.length();i++)
        {
            if (s[i]=='I')
            {
                if (s[i+1]=='V')
                {
                    ans=ans+4;
                    i=i+1;    
                }
                else if (s[i+1]=='X')
                {
                    ans=ans+9;
                    i=i+1;   
                }
                else
                {
                    ans=ans+1;    
                }
            }
            else if (s[i]=='X')
            {
                if (s[i+1]=='L')
                {
                    ans=ans+40;
                    i=i+1;    
                }
                else if (s[i+1]=='C')
                {
                    ans=ans+90;
                    i=i+1; 
                }
                else
                {
                    ans=ans+10;
                }
            }
            else if (s[i]=='C')
            {
                if (s[i+1]=='D')
                {
                    ans=ans+400;
                    i=i+1;
                }
                else if (s[i+1]=='M')
                {
                    ans=ans+900;
                    i=i+1;
                }
                else
                {
                    ans=ans+100;   
                }
            }
            
            else if (s[i]=='V')
            {
                ans=ans+5;    
            }
            else if (s[i]=='L')
            {
                ans=ans+50;   
            }
            else if (s[i]=='D')
            {
                ans=ans+500;    
            }
            else if (s[i]=='M')
            {
                ans=ans+1000;
            }
        
        }
      return ans;  
    }
};


14. Longest Common Prefix

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int n=strs.size();
        if (n==0)
        {
            return "";
        }
        if (n==1)
        {
            return strs[0];
        }
        sort (strs.begin(), strs.begin()+n);
        int en=min(strs[0].size(),strs[n-1].size());
        string first = strs[0], last = strs[n - 1];
        int i = 0;
        while (i < en && first[i] == last[i])
        i++;
 
        string s = first.substr(0, i);
        return s;  
    }
};

20. Valid Parentheses

class Solution {
public:
bool isValid(string s) {
        stack<char> st;
        if (s.length()%2!=0)
        return false;
        for (int i=0;i<s.length();i++)
        {
            if(s[i] == '{' or s[i] == '(' or s[i] == '[')
            {
                st.push(s[i]);
                
            }
            else if (st.empty())
            {
                return false;
            }
            else if ((s[i] == '}' and st.top() == '{') or (s[i] == ']' and st.top() == '[') or (s[i] == ')' and st.top() == '('))
            {
                st.pop();
            }
            else
            {
                return false;
            }
        }
        return (st.empty());
    }
};

21. Merge Two Sorted Lists

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
    {
        ListNode *Head;
        if (!l1)
        return l2;
        if (!l2)
        return l1;

    if (l1->val <= l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }


    }
};

28. Implement strStr()

class Solution {
public:
    int strStr(string haystack, string needle) {
        int result=0;
        for(int i=0;i<haystack.size();i++)
        {
            if (haystack[i]==needle[0])
            {
                result=i;
                int ind=i++;
                int j;
                for (j=1;j<needle.size();j++)
                {
                    if (haystack[i]!=needle[j])
                        {
                            result=0;
                            break;
                        }
                        i++;
                    
                }
                if (j==needle.size())
                    return result;
                
                else
                    i=ind;
                
            }
        
    }
    return -1;
        
    }
};

